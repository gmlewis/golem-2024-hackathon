// Generated by `wit-bindgen` 0.29.0. DO NOT EDIT!
/// UUID
pub struct Uuid {
  high_bits : UInt64
  low_bits : UInt64
} derive(Show, Eq)

/// Represents a Golem component
pub struct ComponentId {
  uuid : Uuid
} derive(Show, Eq)

/// Represents a Golem worker
pub struct WorkerId {
  component_id : ComponentId
  worker_name : String
} derive(Show, Eq)

/// A promise ID is a value that can be passed to an external Golem API to complete that promise
/// from an arbitrary external source, while Golem workers can await for this completion.
pub struct PromiseId {
  worker_id : WorkerId
  oplog_idx : UInt64
} derive(Show, Eq)

/// Configures how the executor retries failures
pub struct RetryPolicy {
  max_attempts : UInt
  min_delay : UInt64
  max_delay : UInt64
  multiplier : Double
} derive(Show, Eq)

/// Configurable persistence level for workers
pub enum PersistenceLevel {
  PersistNothing
  PersistRemoteSideEffects
  Smart
} derive(Show, Eq)

/// Describes how to update a worker to a different component version
pub enum UpdateMode {
  AUTOMATIC
  SNAPSHOT_BASED
} derive(Show, Eq)

pub fn ordinal(self : UpdateMode) -> Int {
  match self {
    AUTOMATIC => 0
    SNAPSHOT_BASED => 1
  }
}

pub fn UpdateMode::from(self : Int) -> UpdateMode {
  match self {
    0 => AUTOMATIC
    1 => SNAPSHOT_BASED
    _ => panic()
  }
}

pub enum FilterComparator {
  EQUAL
  NOT_EQUAL
  GREATER_EQUAL
  GREATER
  LESS_EQUAL
  LESS
} derive(Show, Eq)

pub fn ordinal(self : FilterComparator) -> Int {
  match self {
    EQUAL => 0
    NOT_EQUAL => 1
    GREATER_EQUAL => 2
    GREATER => 3
    LESS_EQUAL => 4
    LESS => 5
  }
}

pub fn FilterComparator::from(self : Int) -> FilterComparator {
  match self {
    0 => EQUAL
    1 => NOT_EQUAL
    2 => GREATER_EQUAL
    3 => GREATER
    4 => LESS_EQUAL
    5 => LESS
    _ => panic()
  }
}

pub enum StringFilterComparator {
  EQUAL
  NOT_EQUAL
  LIKE
  NOT_LIKE
} derive(Show, Eq)

pub fn ordinal(self : StringFilterComparator) -> Int {
  match self {
    EQUAL => 0
    NOT_EQUAL => 1
    LIKE => 2
    NOT_LIKE => 3
  }
}

pub fn StringFilterComparator::from(self : Int) -> StringFilterComparator {
  match self {
    0 => EQUAL
    1 => NOT_EQUAL
    2 => LIKE
    3 => NOT_LIKE
    _ => panic()
  }
}

pub enum WorkerStatus {
  RUNNING
  IDLE
  SUSPENDED
  INTERRUPTED
  RETRYING
  FAILED
  EXITED
} derive(Show, Eq)

pub fn ordinal(self : WorkerStatus) -> Int {
  match self {
    RUNNING => 0
    IDLE => 1
    SUSPENDED => 2
    INTERRUPTED => 3
    RETRYING => 4
    FAILED => 5
    EXITED => 6
  }
}

pub fn WorkerStatus::from(self : Int) -> WorkerStatus {
  match self {
    0 => RUNNING
    1 => IDLE
    2 => SUSPENDED
    3 => INTERRUPTED
    4 => RETRYING
    5 => FAILED
    6 => EXITED
    _ => panic()
  }
}

pub struct WorkerNameFilter {
  comparator : StringFilterComparator
  value : String
} derive(Show, Eq)

pub struct WorkerStatusFilter {
  comparator : FilterComparator
  value : WorkerStatus
} derive(Show, Eq)

pub struct WorkerVersionFilter {
  comparator : FilterComparator
  value : UInt64
} derive(Show, Eq)

pub struct WorkerCreatedAtFilter {
  comparator : FilterComparator
  value : UInt64
} derive(Show, Eq)

pub struct WorkerEnvFilter {
  name : String
  comparator : StringFilterComparator
  value : String
} derive(Show, Eq)

pub enum WorkerPropertyFilter {
  Name(WorkerNameFilter)
  Status(WorkerStatusFilter)
  Version(WorkerVersionFilter)
  CreatedAt(WorkerCreatedAtFilter)
  Env(WorkerEnvFilter)
} derive(Show, Eq)

pub struct WorkerAllFilter {
  filters : Array[WorkerPropertyFilter]
} derive(Show, Eq)

pub struct WorkerAnyFilter {
  filters : Array[WorkerAllFilter]
} derive(Show, Eq)

pub struct WorkerMetadata {
  worker_id : WorkerId
  args : Array[String]
  env : Array[(String, String)]
  status : WorkerStatus
  component_version : UInt64
  retry_count : UInt64
} derive(Show, Eq)

pub type GetWorkers Int derive(Show, Eq)

fn wasmImportResourceDropGetWorkers(resource : Int) = "golem:api/host@0.2.0" "[resource-drop]get-workers"

pub fn GetWorkers::drop(self : GetWorkers) -> Unit {
  wasmImportResourceDropGetWorkers(self.0)
}

pub fn GetWorkers::get_workers(
  component_id : ComponentId,
  filter : WorkerAnyFilter?,
  precise : Bool
) -> GetWorkers {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let (lowered, lowered24, lowered25) = match filter {
    None => (0, 0, 0)
    Some(payload2) => {
      let address22 = @ffi.malloc(payload2.filters.length() * 8)
      for index23 = 0
          index23 < payload2.filters.length()
          index23 = index23 + 1 {
        let element3 : WorkerAllFilter = payload2.filters[index23]
        let base4 = address22 + index23 * 8
        let address = @ffi.malloc(element3.filters.length() * 32)
        for index = 0; index < element3.filters.length(); index = index + 1 {
          let element5 : WorkerPropertyFilter = element3.filters[index]
          let base6 = address + index * 32
          match element5 {
            Name(payload9) => {
              @ffi.store8(base6 + 0, 0)
              @ffi.store8(base6 + 8, payload9.comparator.ordinal())
              @ffi.store32(base6 + 16, payload9.value.iter().count())
              @ffi.store32(base6 + 12, @ffi.str2ptr(payload9.value))
              ignoreList.push(payload9.value)
              ()
            }
            Status(payload12) => {
              @ffi.store8(base6 + 0, 1)
              @ffi.store8(base6 + 8, payload12.comparator.ordinal())
              @ffi.store8(base6 + 9, payload12.value.ordinal())
              ()
            }
            Version(payload15) => {
              @ffi.store8(base6 + 0, 2)
              @ffi.store8(base6 + 8, payload15.comparator.ordinal())
              @ffi.store64(base6 + 16, payload15.value.to_int64())
              ()
            }
            CreatedAt(payload18) => {
              @ffi.store8(base6 + 0, 3)
              @ffi.store8(base6 + 8, payload18.comparator.ordinal())
              @ffi.store64(base6 + 16, payload18.value.to_int64())
              ()
            }
            Env(payload21) => {
              @ffi.store8(base6 + 0, 4)
              @ffi.store32(base6 + 12, payload21.name.iter().count())
              @ffi.store32(base6 + 8, @ffi.str2ptr(payload21.name))
              @ffi.store8(base6 + 16, payload21.comparator.ordinal())
              @ffi.store32(base6 + 24, payload21.value.iter().count())
              @ffi.store32(base6 + 20, @ffi.str2ptr(payload21.value))
              ignoreList.push(payload21.name)
              ignoreList.push(payload21.value)
              ()
            }
            // _ => panic()
          }
        }
        @ffi.store32(base4 + 4, element3.filters.length())
        @ffi.store32(base4 + 0, address)
        cleanupList.push(
          { address, size: element3.filters.length() * 32, align: 8 },
        )
      }
      cleanupList.push(
        { address: address22, size: payload2.filters.length() * 8, align: 4 },
      )
      (1, address22, payload2.filters.length())
    }
  }
  let result : Int = wasmImportConstructorGetWorkers(
    component_id.uuid.high_bits.to_int64(),
    component_id.uuid.low_bits.to_int64(),
    lowered,
    lowered24,
    lowered25,
    if precise {
      1
    } else {
      0
    },
  )
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return GetWorkers::GetWorkers(result)
}

pub fn GetWorkers::get_next(self : GetWorkers) -> Array[WorkerMetadata]? {
  let return_area = @ffi.malloc(12)
  wasmImportMethodGetWorkersGetNext(self.0, return_area)
  let lifted : Array[WorkerMetadata]? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let array13 : Array[WorkerMetadata] = []
      for index14 = 0
          index14 < @ffi.load32(return_area + 8)
          index14 = index14 + 1 {
        let base3 = @ffi.load32(return_area + 4) + index14 * 64
        let result = @ffi.ptr2str(@ffi.load32(base3 + 16))
        let array : Array[String] = []
        for index = 0; index < @ffi.load32(base3 + 28); index = index + 1 {
          let base5 = @ffi.load32(base3 + 24) + index * 8
          let result6 = @ffi.ptr2str(@ffi.load32(base5 + 0))
          array.push(result6)
        }
        @ffi.free(@ffi.load32(base3 + 24))
        let array11 : Array[(String, String)] = []
        for index12 = 0
            index12 < @ffi.load32(base3 + 36)
            index12 = index12 + 1 {
          let base8 = @ffi.load32(base3 + 32) + index12 * 16
          let result9 = @ffi.ptr2str(@ffi.load32(base8 + 0))
          let result10 = @ffi.ptr2str(@ffi.load32(base8 + 8))
          array11.push((result9, result10))
        }
        @ffi.free(@ffi.load32(base3 + 32))
        array13.push(
          WorkerMetadata::{
            worker_id: WorkerId::{
              component_id: ComponentId::{
                uuid: Uuid::{
                  high_bits: @ffi.load64(base3 + 0).to_uint64(),
                  low_bits: @ffi.load64(base3 + 8).to_uint64(),
                },
              },
              worker_name: result,
            },
            args: array,
            env: array11,
            status: WorkerStatus::from(@ffi.load8_u(base3 + 40)),
            component_version: @ffi.load64(base3 + 48).to_uint64(),
            retry_count: @ffi.load64(base3 + 56).to_uint64(),
          },
        )
      }
      @ffi.free(@ffi.load32(return_area + 4))
      Option::Some(array13)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

/// Create a new promise
pub fn create_promise() -> PromiseId {
  let return_area = @ffi.malloc(32)
  wasmImportCreatePromise(return_area)
  let result = @ffi.ptr2str(@ffi.load32(return_area + 16))
  @ffi.free(return_area)
  return PromiseId::{
    worker_id: WorkerId::{
      component_id: ComponentId::{
        uuid: Uuid::{
          high_bits: @ffi.load64(return_area + 0).to_uint64(),
          low_bits: @ffi.load64(return_area + 8).to_uint64(),
        },
      },
      worker_name: result,
    },
    oplog_idx: @ffi.load64(return_area + 24).to_uint64(),
  }
}

/// Suspends execution until the given promise gets completed, and returns the payload passed to
/// the promise completion.
pub fn await_promise(promise_id : PromiseId) -> Bytes {
  let return_area = @ffi.malloc(8)
  wasmImportAwaitPromise(
    promise_id.worker_id.component_id.uuid.high_bits.to_int64(),
    promise_id.worker_id.component_id.uuid.low_bits.to_int64(),
    @ffi.str2ptr(promise_id.worker_id.worker_name),
    promise_id.worker_id.worker_name.iter().count(),
    promise_id.oplog_idx.to_int64(),
    return_area,
  )
  let result = @ffi.ptr2bytes(@ffi.load32(return_area + 0))
  ignore(promise_id.worker_id.worker_name)
  @ffi.free(return_area)
  return result
}

/// Completes the given promise with the given payload. Returns true if the promise was completed, false
/// if the promise was already completed. The payload is passed to the worker that is awaiting the promise.
pub fn complete_promise(promise_id : PromiseId, data : Bytes) -> Bool {
  let result : Int = wasmImportCompletePromise(
    promise_id.worker_id.component_id.uuid.high_bits.to_int64(),
    promise_id.worker_id.component_id.uuid.low_bits.to_int64(),
    @ffi.str2ptr(promise_id.worker_id.worker_name),
    promise_id.worker_id.worker_name.iter().count(),
    promise_id.oplog_idx.to_int64(),
    @ffi.bytes2ptr(data),
    data.length(),
  )
  ignore(promise_id.worker_id.worker_name)
  ignore(data)
  return result != 0
}

/// Deletes the given promise
pub fn delete_promise(promise_id : PromiseId) -> Unit {
  wasmImportDeletePromise(
    promise_id.worker_id.component_id.uuid.high_bits.to_int64(),
    promise_id.worker_id.component_id.uuid.low_bits.to_int64(),
    @ffi.str2ptr(promise_id.worker_id.worker_name),
    promise_id.worker_id.worker_name.iter().count(),
    promise_id.oplog_idx.to_int64(),
  )
  ignore(promise_id.worker_id.worker_name)
}

/// Returns a Golem worker URI that can be used to invoke a given function on the current worker
pub fn get_self_uri(function_name : String) -> @types.Uri {
  let return_area = @ffi.malloc(8)
  wasmImportGetSelfUri(
    @ffi.str2ptr(function_name),
    function_name.iter().count(),
    return_area,
  )
  let result = @ffi.ptr2str(@ffi.load32(return_area + 0))
  ignore(function_name)
  @ffi.free(return_area)
  return @types.Uri::{ value: result }
}

/// Returns the current position in the persistent op log
pub fn get_oplog_index() -> UInt64 {
  let result : Int64 = wasmImportGetOplogIndex()
  return result.to_uint64()
}

/// Makes the current worker travel back in time and continue execution from the given position in the persistent
/// op log.
pub fn set_oplog_index(oplog_idx : UInt64) -> Unit {
  wasmImportSetOplogIndex(oplog_idx.to_int64())
}

/// Blocks the execution until the oplog has been written to at least the specified number of replicas,
/// or the maximum number of replicas if the requested number is higher.
pub fn oplog_commit(replicas : Byte) -> Unit {
  wasmImportOplogCommit(replicas.to_int())
}

/// Marks the beginning of an atomic operation.
/// In case of a failure within the region selected by `mark-begin-operation` and `mark-end-operation`
/// the whole region will be reexecuted on retry.
/// The end of the region is when `mark-end-operation` is called with the returned oplog-index.
pub fn mark_begin_operation() -> UInt64 {
  let result : Int64 = wasmImportMarkBeginOperation()
  return result.to_uint64()
}

/// Commits this atomic operation. After `mark-end-operation` is called for a given index, further calls
/// with the same parameter will do nothing.
pub fn mark_end_operation(begin : UInt64) -> Unit {
  wasmImportMarkEndOperation(begin.to_int64())
}

/// Gets the current retry policy associated with the worker
pub fn get_retry_policy() -> RetryPolicy {
  let return_area = @ffi.malloc(32)
  wasmImportGetRetryPolicy(return_area)
  @ffi.free(return_area)
  return RetryPolicy::{
    max_attempts: @ffi.load32(return_area + 0).to_uint(),
    min_delay: @ffi.load64(return_area + 8).to_uint64(),
    max_delay: @ffi.load64(return_area + 16).to_uint64(),
    multiplier: @ffi.loadf64(return_area + 24),
  }
}

/// Overrides the current retry policy associated with the worker. Following this call, `get-retry-policy` will return the
/// new retry policy.
pub fn set_retry_policy(new_retry_policy : RetryPolicy) -> Unit {
  wasmImportSetRetryPolicy(
    new_retry_policy.max_attempts.to_int(),
    new_retry_policy.min_delay.to_int64(),
    new_retry_policy.max_delay.to_int64(),
    new_retry_policy.multiplier,
  )
}

/// Gets the worker's current persistence level.
pub fn get_oplog_persistence_level() -> PersistenceLevel {
  let result : Int = wasmImportGetOplogPersistenceLevel()
  let lifted = match result {
    0 => PersistenceLevel::PersistNothing
    1 => PersistenceLevel::PersistRemoteSideEffects
    2 => PersistenceLevel::Smart
    _ => panic()
  }
  return lifted
}

/// Sets the worker's current persistence level. This can increase the performance of execution in cases where durable
/// execution is not required.
pub fn set_oplog_persistence_level(
  new_persistence_level : PersistenceLevel
) -> Unit {
  let lowered = match new_persistence_level {
    PersistNothing => 0
    PersistRemoteSideEffects => 1
    Smart => 2
    // _ => panic()
  }
  wasmImportSetOplogPersistenceLevel(lowered)
}

/// Gets the current idempotence mode. See `set-idempotence-mode` for details.
pub fn get_idempotence_mode() -> Bool {
  let result : Int = wasmImportGetIdempotenceMode()
  return result != 0
}

/// Sets the current idempotence mode. The default is true.
/// True means side-effects are treated idempotent and Golem guarantees at-least-once semantics.
/// In case of false the executor provides at-most-once semantics, failing the worker in case it is
/// not known if the side effect was already executed.
pub fn set_idempotence_mode(idempotent : Bool) -> Unit {
  wasmImportSetIdempotenceMode(if idempotent { 1 } else { 0 })
}

/// Generates an idempotency key. This operation will never be replayed —
/// i.e. not only is this key generated, but it is persisted and committed, such that the key can be used in third-party systems (e.g. payment processing)
/// to introduce idempotence.
pub fn generate_idempotency_key() -> Uuid {
  let return_area = @ffi.malloc(16)
  wasmImportGenerateIdempotencyKey(return_area)
  @ffi.free(return_area)
  return Uuid::{
    high_bits: @ffi.load64(return_area + 0).to_uint64(),
    low_bits: @ffi.load64(return_area + 8).to_uint64(),
  }
}

/// Initiates an update attempt for the given worker. The function returns immediately once the request has been processed,
/// not waiting for the worker to get updated.
pub fn update_worker(
  worker_id : WorkerId,
  target_version : UInt64,
  mode : UpdateMode
) -> Unit {
  wasmImportUpdateWorker(
    worker_id.component_id.uuid.high_bits.to_int64(),
    worker_id.component_id.uuid.low_bits.to_int64(),
    @ffi.str2ptr(worker_id.worker_name),
    worker_id.worker_name.iter().count(),
    target_version.to_int64(),
    mode.ordinal(),
  )
  ignore(worker_id.worker_name)
}

/// Get current worker metadata
pub fn get_self_metadata() -> WorkerMetadata {
  let return_area = @ffi.malloc(64)
  wasmImportGetSelfMetadata(return_area)
  let result = @ffi.ptr2str(@ffi.load32(return_area + 16))
  let array : Array[String] = []
  for index = 0; index < @ffi.load32(return_area + 28); index = index + 1 {
    let base = @ffi.load32(return_area + 24) + index * 8
    let result0 = @ffi.ptr2str(@ffi.load32(base + 0))
    array.push(result0)
  }
  @ffi.free(@ffi.load32(return_area + 24))
  let array5 : Array[(String, String)] = []
  for index6 = 0; index6 < @ffi.load32(return_area + 36); index6 = index6 + 1 {
    let base2 = @ffi.load32(return_area + 32) + index6 * 16
    let result3 = @ffi.ptr2str(@ffi.load32(base2 + 0))
    let result4 = @ffi.ptr2str(@ffi.load32(base2 + 8))
    array5.push((result3, result4))
  }
  @ffi.free(@ffi.load32(return_area + 32))
  @ffi.free(return_area)
  return WorkerMetadata::{
    worker_id: WorkerId::{
      component_id: ComponentId::{
        uuid: Uuid::{
          high_bits: @ffi.load64(return_area + 0).to_uint64(),
          low_bits: @ffi.load64(return_area + 8).to_uint64(),
        },
      },
      worker_name: result,
    },
    args: array,
    env: array5,
    status: WorkerStatus::from(@ffi.load8_u(return_area + 40)),
    component_version: @ffi.load64(return_area + 48).to_uint64(),
    retry_count: @ffi.load64(return_area + 56).to_uint64(),
  }
}

/// Get worker metadata
pub fn get_worker_metadata(worker_id : WorkerId) -> WorkerMetadata? {
  let return_area = @ffi.malloc(72)
  wasmImportGetWorkerMetadata(
    worker_id.component_id.uuid.high_bits.to_int64(),
    worker_id.component_id.uuid.low_bits.to_int64(),
    @ffi.str2ptr(worker_id.worker_name),
    worker_id.worker_name.iter().count(),
    return_area,
  )
  let lifted : WorkerMetadata? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let result = @ffi.ptr2str(@ffi.load32(return_area + 24))
      let array : Array[String] = []
      for index = 0; index < @ffi.load32(return_area + 36); index = index + 1 {
        let base3 = @ffi.load32(return_area + 32) + index * 8
        let result4 = @ffi.ptr2str(@ffi.load32(base3 + 0))
        array.push(result4)
      }
      @ffi.free(@ffi.load32(return_area + 32))
      let array9 : Array[(String, String)] = []
      for index10 = 0
          index10 < @ffi.load32(return_area + 44)
          index10 = index10 + 1 {
        let base6 = @ffi.load32(return_area + 40) + index10 * 16
        let result7 = @ffi.ptr2str(@ffi.load32(base6 + 0))
        let result8 = @ffi.ptr2str(@ffi.load32(base6 + 8))
        array9.push((result7, result8))
      }
      @ffi.free(@ffi.load32(return_area + 40))
      Option::Some(
        WorkerMetadata::{
          worker_id: WorkerId::{
            component_id: ComponentId::{
              uuid: Uuid::{
                high_bits: @ffi.load64(return_area + 8).to_uint64(),
                low_bits: @ffi.load64(return_area + 16).to_uint64(),
              },
            },
            worker_name: result,
          },
          args: array,
          env: array9,
          status: WorkerStatus::from(@ffi.load8_u(return_area + 48)),
          component_version: @ffi.load64(return_area + 56).to_uint64(),
          retry_count: @ffi.load64(return_area + 64).to_uint64(),
        },
      )
    }
    _ => panic()
  }
  ignore(worker_id.worker_name)
  @ffi.free(return_area)
  return lifted
}
